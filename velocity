#!/usr/bin/env python3

############################################################
# import
############################################################
import argparse
import re
import subprocess
import yaml
from colorama import Fore, Style
from lib.graph import Node, ImageGraph, Target, DepOp
from lib.build import Builder
from lib.print import h1print, p1print, sp1print, TextBlock, print_text_blocks

############################################################
# Main
############################################################
if __name__ == '__main__':
    ############################################################
    # Load settings & Config
    ############################################################
    with open('settings.yaml', 'r') as file:
        SETTINGS = yaml.safe_load(file)
    LATEST_GIT_COMMIT = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).decode()
    VERSION = f"{SETTINGS['VERSION']}.{LATEST_GIT_COMMIT}"

    ############################################################
    # Load images
    ############################################################
    imageGraph = ImageGraph(SETTINGS['IMAGE_DIRECTORY'], SETTINGS['BACKEND'], SETTINGS['SYSTEM'], SETTINGS['DISTRO'])

    ############################################################
    # Parse Args
    ############################################################
    parser = argparse.ArgumentParser(
        prog='velocity',
        description='Build tool for OLCF containers',
        epilog='See (https://gitlab.ccs.ornl.gov/saue-software/velocity)')
    parser.add_argument('-v', '--version', action='version',
                        version=f"%(prog)s {VERSION}", help="program version")

    # create sub_parser
    sub_parsers = parser.add_subparsers(dest='subcommand')

    # create build_parser
    build_parser = sub_parsers.add_parser('build', help="build specified container image")
    build_parser.add_argument('-d', '--dry-run', action='store_true', help="dry run build system")
    build_parser.add_argument('targets', type=str, nargs='+', help='build targets')
    build_parser.add_argument('-n', '--name', action='store', help='name of complete image')
    build_parser.add_argument('-l', '--leave-tags', action='store_true',
                              help="do not clean up intermediate build tags (only applies to podman)")

    # create avail_parser
    avail_parser = sub_parsers.add_parser('avail', help="lookup available images")

    # create spec_parser
    spec_parser = sub_parsers.add_parser('spec', help="lookup image dependencies")
    spec_parser.add_argument('targets', type=str, nargs='+', help='spec targets')

    args = parser.parse_args()

    ############################################################
    # Handle User Commands
    ############################################################
    if args.subcommand == 'build':
        # parse targets
        h1print("BUILD SPECS")
        targets = []
        for target in args.targets:
            result = re.search(r'^(.*)@(.*)([%^_=])(.*)$', target)
            if result is not None:
                if result[3] == '=':
                    targets.append(Target(Node(result[1], result[4]), DepOp.EQ))
                elif result[3] == '^':
                    targets.append(Target(Node(result[1], result[4]), DepOp.GE))
                elif result[3] == '_':
                    targets.append(Target(Node(result[1], result[4]), DepOp.LE))
                elif result[3] == '%':
                    targets.append(Target(Node(result[1], result[2]), DepOp.GE))
                    targets.append(Target(Node(result[1], result[4]), DepOp.LE))
            else:
                targets.append(Target(Node(target, ''), DepOp.UN))

        # get recipe
        recipe = imageGraph.create_build_recipe(targets)

        # print build specs
        p1print([
            TextBlock(f"Backend: "),
            TextBlock(f"{SETTINGS['BACKEND']}", fore=Fore.MAGENTA, style=Style.BRIGHT)
        ])
        p1print([
            TextBlock(f"System: "),
            TextBlock(f"{SETTINGS['SYSTEM']}", fore=Fore.MAGENTA, style=Style.BRIGHT)
        ])
        p1print([
            TextBlock(f"Distro: "),
            TextBlock(f"{SETTINGS['DISTRO']}", fore=Fore.MAGENTA, style=Style.BRIGHT)
        ])
        p1print([
            TextBlock(f"Images: ")
        ])
        for r in recipe:
            sp1print([
                TextBlock(f"{r.name}@={r.tag}", fore=Fore.MAGENTA, style=Style.BRIGHT)
            ])
        print()

        # prep builder
        builder = Builder(recipe, SETTINGS['BACKEND'], SETTINGS['SYSTEM'], SETTINGS['DISTRO'],
                          build_name=args.name, dry_run=args.dry_run, leave_tags=args.leave_tags,
                          build_dir=SETTINGS['BUILD_DIRECTORY'])

        # build
        h1print("BUILD")
        builder.build()

    elif args.subcommand == 'avail':
        h1print("AVAILABLE IMAGES")
        p1print([
            TextBlock(f"System: "),
            TextBlock(f"{SETTINGS['SYSTEM']}", fore=Fore.MAGENTA, style=Style.BRIGHT)
        ])
        p1print([
            TextBlock(f"Distro: "),
            TextBlock(f"{SETTINGS['DISTRO']}", fore=Fore.MAGENTA, style=Style.BRIGHT)
        ])

        # group and order
        grouped = dict()
        for node in imageGraph.nodes:
            if node.name not in grouped:
                grouped[node.name] = list()
            grouped[node.name].append(node)
        ordered = list(grouped.keys())
        ordered.sort()

        # print
        for group in ordered:
            p1print([
                TextBlock(group, fore=Fore.RED, style=Style.BRIGHT)
            ])
            deps = grouped[group]
            deps.sort()
            for t in deps:
                sp1print([
                    TextBlock(t.tag, fore=Fore.YELLOW, style=Style.BRIGHT)
                ])

    elif args.subcommand == 'spec':
        # parse targets
        targets = []
        for target in args.targets:
            result = re.search(r'^(.*)@(.*)([%^_=])(.*)$', target)
            if result is not None:
                if result[3] == '=':
                    targets.append(Target(Node(result[1], SETTINGS['SYSTEM'], SETTINGS['DISTRO'], result[4]), DepOp.EQ))
                elif result[3] == '^':
                    targets.append(Target(Node(result[1], SETTINGS['SYSTEM'], SETTINGS['DISTRO'], result[4]), DepOp.GE))
                elif result[3] == '_':
                    targets.append(Target(Node(result[1], SETTINGS['SYSTEM'], SETTINGS['DISTRO'], result[4]), DepOp.LE))
                elif result[3] == '%':
                    targets.append(Target(Node(result[1], SETTINGS['SYSTEM'], SETTINGS['DISTRO'], result[2]), DepOp.GE))
                    targets.append(Target(Node(result[1], SETTINGS['SYSTEM'], SETTINGS['DISTRO'], result[4]), DepOp.LE))
            else:
                targets.append(Target(Node(target, SETTINGS['SYSTEM'], SETTINGS['DISTRO'], ''), DepOp.UN))

        # get recipe
        recipe = imageGraph.create_build_recipe(targets)

        flat_dep_tree = dict()
        for r in recipe:
            flat_dep_tree[r.name] = set()
            deps = set(imageGraph.get_dependencies(r))
            for o in deps.intersection(set(recipe)):
                flat_dep_tree[r.name].add(o.name)
        top_level_entries = set()
        deps = set()
        for r in recipe:
            deps.update(imageGraph.get_dependencies(r))
        for r in recipe:
            if r not in deps:
                top_level_entries.add(r)

        def spec_print(seed: str, indent: int, fdt: dict, rs: tuple[Node]):
            """
            Recursive function to print dep tree
            """
            spec = None
            for _ in rs:
                if _.similar(Node(seed, SETTINGS['SYSTEM'], SETTINGS['DISTRO'], '')):
                    spec = f"{_.name}@={_.tag}"
            print('  ' + '   ' * indent, end='')
            if indent == 0:
                print_text_blocks([
                    TextBlock('> ', fore=Fore.RED, style=Style.BRIGHT),
                    TextBlock(spec, fore=Fore.MAGENTA, style=Style.BRIGHT)
                ])
            else:
                print_text_blocks([
                    TextBlock('^', fore=Fore.GREEN, style=Style.BRIGHT),
                    TextBlock(spec, fore=Fore.MAGENTA, style=Style.BRIGHT)
                ])
            if len(fdt[seed]) > 0:
                for un in fdt[seed]:
                    spec_print(un, (indent + 1), fdt, rs)

        h1print(f"SPEC FOR {' '.join(_ for _ in args.targets)}")
        for tl in top_level_entries:
            spec_print(tl.name, 0, flat_dep_tree, recipe)

    else:
        parser.print_help()
