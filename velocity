#!/usr/bin/env python3

import argparse
import re
import subprocess
import yaml
from colorama import Fore, Style
from lib.graph import Node, ImageGraph, Target, DepOp
from lib.build import Builder
from lib.print import p1print, sp1print, TextBlock, print_text_blocks

############################################################
# Main
############################################################
if __name__ == '__main__':

    ############################################################
    # Load settings & Config
    ############################################################
    with open('settings.yaml', 'r') as file:
        SETTINGS = yaml.safe_load(file)
    LATEST_GIT_COMMIT = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).decode()
    VERSION = f"{SETTINGS['VERSION']}.{LATEST_GIT_COMMIT}"

    ############################################################
    # Parse Args
    ############################################################
    parser = argparse.ArgumentParser(
        prog='velocity',
        description='Build tool for OLCF containers',
        epilog='See (https://gitlab.ccs.ornl.gov/saue-software/velocity)')
    parser.add_argument('-v', '--version', action='version',
                        version=f"%(prog)s {VERSION}", help="program version")
    parser.add_argument('-b', '--backend', action='store', help="specify build system backend")

    # create sub_parsers
    sub_parsers = parser.add_subparsers(dest='subcommand')

    # create build_parser
    build_parser = sub_parsers.add_parser('build', help="build specified container image")
    build_parser.add_argument('-d', '--dry-run', action='store_true', help="dry run build system")
    build_parser.add_argument('targets', type=str, nargs='+', help='build targets')
    build_parser.add_argument('-n', '--name', action='store', help='name of complete image')
    build_parser.add_argument('-l', '--leave-tags', action='store_true',
                              help="do not clean up intermediate build tags (only applies to podman)")

    # create avail_parser
    avail_parser = sub_parsers.add_parser('avail', help="lookup available images")

    # create spec_parser
    spec_parser = sub_parsers.add_parser('spec', help="lookup image dependencies")
    spec_parser.add_argument('targets', type=str, nargs='+', help='spec targets')

    # parse args
    args = parser.parse_args()

    ############################################################
    # apply user run time arguments over settings
    ############################################################
    SETTINGS['BACKEND'] = args.backend if args.backend is not None else SETTINGS['BACKEND']

    ############################################################
    # Load images
    ############################################################
    imageGraph = ImageGraph(SETTINGS['IMAGE_DIRECTORY'], SETTINGS['BACKEND'], SETTINGS['SYSTEM'], SETTINGS['DISTRO'])

    # print backend, system, distro
    p1print([
        TextBlock(f"Backend: "),
        TextBlock(f"{SETTINGS['BACKEND']}", fore=Fore.MAGENTA, style=Style.BRIGHT)
    ])
    p1print([
        TextBlock(f"System: "),
        TextBlock(f"{SETTINGS['SYSTEM']}", fore=Fore.MAGENTA, style=Style.BRIGHT)
    ])
    p1print([
        TextBlock(f"Distro: "),
        TextBlock(f"{SETTINGS['DISTRO']}", fore=Fore.MAGENTA, style=Style.BRIGHT)
    ])
    print()     # add newline

    ############################################################
    # Handle User Commands
    ############################################################
    if args.subcommand == 'build':
        # parse targets
        targets = []
        for target in args.targets:
            result = re.search(r'^(.*)@(.*)([%^_=])(.*)$', target)
            if result is not None:
                if result[3] == '=':
                    targets.append(Target(Node(result[1], result[4]), DepOp.EQ))
                elif result[3] == '^':
                    targets.append(Target(Node(result[1], result[4]), DepOp.GE))
                elif result[3] == '_':
                    targets.append(Target(Node(result[1], result[4]), DepOp.LE))
                elif result[3] == '%':
                    targets.append(Target(Node(result[1], result[2]), DepOp.GE))
                    targets.append(Target(Node(result[1], result[4]), DepOp.LE))
            else:
                targets.append(Target(Node(target, ''), DepOp.UN))

        # get recipe
        recipe = imageGraph.create_build_recipe(targets)

        # print build specs
        p1print([
            TextBlock('Build Order:')
        ])
        for r in recipe:
            sp1print([
                TextBlock(f"{r.name}@={r.tag}", fore=Fore.MAGENTA, style=Style.BRIGHT)
            ])
        print()     # add newline

        # prep builder
        builder = Builder(recipe, SETTINGS['BACKEND'], SETTINGS['SYSTEM'], SETTINGS['DISTRO'],
                          build_name=args.name, dry_run=args.dry_run, leave_tags=args.leave_tags,
                          build_dir=SETTINGS['BUILD_DIRECTORY'])

        # build
        builder.build()

    elif args.subcommand == 'avail':

        # group and order
        grouped = dict()
        for node in imageGraph.nodes:
            if node.name not in grouped:
                grouped[node.name] = list()
            grouped[node.name].append(node)
        ordered = list(grouped.keys())
        ordered.sort()

        # print
        for group in ordered:
            p1print([
                TextBlock(group, fore=Fore.RED, style=Style.BRIGHT)
            ])
            deps = grouped[group]
            deps.sort()
            for t in deps:
                sp1print([
                    TextBlock(t.tag, fore=Fore.YELLOW, style=Style.BRIGHT)
                ])
        print()  # add newline

    elif args.subcommand == 'spec':
        # parse targets
        targets = []
        for target in args.targets:
            result = re.search(r'^(.*)@(.*)([%^_=])(.*)$', target)
            if result is not None:
                if result[3] == '=':
                    targets.append(Target(Node(result[1], result[4]), DepOp.EQ))
                elif result[3] == '^':
                    targets.append(Target(Node(result[1], result[4]), DepOp.GE))
                elif result[3] == '_':
                    targets.append(Target(Node(result[1], result[4]), DepOp.LE))
                elif result[3] == '%':
                    targets.append(Target(Node(result[1], result[2]), DepOp.GE))
                    targets.append(Target(Node(result[1], result[4]), DepOp.LE))
            else:
                targets.append(Target(Node(target, ''), DepOp.UN))

        # get recipe
        recipe = imageGraph.create_build_recipe(targets)

        # flatten dependency tree
        flat_dep_tree = dict()
        for r in recipe:
            flat_dep_tree[r.name] = set()
            deps = set(imageGraph.get_dependencies(r))
            for o in deps.intersection(set(recipe)):
                flat_dep_tree[r.name].add(o.name)
        # get top level entries
        top_level_entries = set()
        deps = set()
        for r in recipe:
            deps.update(imageGraph.get_dependencies(r))
        for r in recipe:
            if r not in deps:
                top_level_entries.add(r)

        def spec_print(seed: str, indent: int, fdt: dict, rs: tuple[Node]):
            """
            Recursive function to print dep tree
            """
            spec = None
            for _ in rs:
                if _.similar(Node(seed, '')):
                    spec = f"{_.name}@={_.tag}"
            print('  ' + '   ' * indent, end='')
            if indent == 0:
                print_text_blocks([
                    TextBlock('> ', fore=Fore.RED, style=Style.BRIGHT),
                    TextBlock(spec, fore=Fore.MAGENTA, style=Style.BRIGHT)
                ])
            else:
                print_text_blocks([
                    TextBlock('^', fore=Fore.GREEN, style=Style.BRIGHT),
                    TextBlock(spec, fore=Fore.MAGENTA, style=Style.BRIGHT)
                ])
            if len(fdt[seed]) > 0:
                for un in fdt[seed]:
                    spec_print(un, (indent + 1), fdt, rs)

        # print specs
        for tl in top_level_entries:
            spec_print(tl.name, 0, flat_dep_tree, recipe)
        print()  # add newline

    else:
        parser.print_help()
